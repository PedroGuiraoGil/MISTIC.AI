name: Actualizar EPG

on:
  schedule:
    - cron: '0 6,12,18,0 * * *'   # 4 veces al día: 6h, 12h, 18h, 0h UTC
  workflow_dispatch:                # también se puede lanzar a mano desde GitHub

jobs:
  update-epg:
    runs-on: ubuntu-latest
    permissions:
      contents: write               # necesario para hacer git push

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Descargar XML del EPG_dobleM
        run: |
          curl -L --max-time 60 --retry 3 \
            "https://raw.githubusercontent.com/davidmuma/EPG_dobleM/master/guiatv.xml" \
            -o guiatv.xml
          echo "Tamaño XML: $(wc -c < guiatv.xml) bytes"

      - name: Convertir XML a JSON con Python
        run: |
          python3 << 'PYEOF'
          import xml.etree.ElementTree as ET
          import json, re
          from datetime import datetime, timezone, timedelta

          CANALES = {
              'Movistar Plus+':      ['M+ Plus HD','M+ Plus FHD','Movistar Plus+ HD'],
              'Movistar LaLiga':     ['M+ LaLiga HD','M+ LaLiga 1 HD','Movistar LaLiga HD'],
              'DAZN LaLiga':         ['DAZN LaLiga HD','DAZN LaLiga'],
              'Liga de Campeones':   ['M+ Liga de Campeones HD','M+ Liga Campeones HD','Liga de Campeones HD'],
              'Movistar Deportes':   ['M+ Deportes HD','M+ Deportes 1 HD','Movistar Deportes HD'],
              'Movistar Deportes 2': ['M+ Deportes 2 HD','Movistar Deportes 2 HD'],
              'Vamos':               ['M+ Vamos HD','Vamos HD'],
              'Teledeporte':         ['Teledeporte HD','Teledeporte'],
              'Eurosport 1':         ['Eurosport 1 HD','Eurosport1 HD','Eurosport 1'],
              'Eurosport 2':         ['Eurosport 2 HD','Eurosport2 HD','Eurosport 2'],
              'DAZN 1':              ['DAZN 1 HD','DAZN1 HD','DAZN 1'],
              'DAZN 2':              ['DAZN 2 HD','DAZN2 HD','DAZN 2'],
              'Esport3':             ['Esport3 HD','Esport 3 HD','Esport3'],
              'Canal Historia':      ['History Channel HD','Historia HD','Canal Historia HD'],
              'DMAX':                ['DMAX HD','DMAX'],
              'Odisea':              ['Odisea HD','Odisea'],
          }

          def ts_to_iso(ts):
              """Convierte '20250224143000 +0100' a datetime UTC"""
              m = re.match(r'^(\d{14})\s*([+-]\d{4})?', ts)
              if not m: return None
              dt_str, tz_str = m.group(1), m.group(2) or '+0000'
              dt = datetime.strptime(dt_str, '%Y%m%d%H%M%S')
              sign = 1 if tz_str[0]=='+' else -1
              off  = timedelta(hours=int(tz_str[1:3]), minutes=int(tz_str[3:5])) * sign
              return dt - off  # UTC

          def fmt(dt):
              """UTC datetime → 'HH:MM' en hora de España (UTC+1 invierno / UTC+2 verano)"""
              # Aproximación: si mes en [3..10] usar UTC+2, resto UTC+1
              offset = 2 if 3 <= dt.month <= 10 else 1
              local = dt + timedelta(hours=offset)
              return local.strftime('%H:%M')

          tree = ET.parse('guiatv.xml')
          root = tree.getroot()

          # Construir mapa inverso: id_xml → label
          id_map = {}
          for label, ids in CANALES.items():
              for xid in ids:
                  id_map[xid] = label

          # También buscar coincidencias en los <channel> del XML
          xml_ids = {}  # id → display-name
          for ch in root.findall('channel'):
              cid = ch.get('id','')
              names = [n.text for n in ch.findall('display-name') if n.text]
              xml_ids[cid] = names
              # Intentar mapear por nombre si no está en id_map
              for nm in names:
                  if nm in id_map and cid not in id_map:
                      id_map[cid] = id_map[nm]

          print(f"IDs en XML: {list(xml_ids.keys())[:20]}")

          today = datetime.now(timezone.utc).date()
          result = {label: [] for label in CANALES}

          for prog in root.findall('programme'):
              cid   = prog.get('channel','')
              start = prog.get('start','')
              stop  = prog.get('stop','')
              title = prog.findtext('title','').strip()

              label = id_map.get(cid)
              if not label: continue

              dt_start = ts_to_iso(start)
              dt_stop  = ts_to_iso(stop)
              if not dt_start: continue
              if dt_start.date() != today: continue

              result[label].append({
                  'inicio': fmt(dt_start),
                  'fin':    fmt(dt_stop) if dt_stop else None,
                  'titulo': title
              })

          # Ordenar por hora
          for label in result:
              result[label].sort(key=lambda x: x['inicio'])
              print(f"  {label}: {len(result[label])} programas")

          output = {
              'actualizado': datetime.now(timezone.utc).isoformat(),
              'canales': result
          }

          with open('epg.json', 'w', encoding='utf-8') as f:
              json.dump(output, f, ensure_ascii=False, indent=2)

          print(f"\nepg.json generado OK")
          PYEOF

      - name: Commit y push del JSON
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add epg.json
          # Solo hacer commit si hay cambios reales
          git diff --staged --quiet || git commit -m "EPG actualizado $(date -u '+%Y-%m-%d %H:%M UTC')"
          git push
