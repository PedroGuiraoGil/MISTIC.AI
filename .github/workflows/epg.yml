name: Actualizar EPG

on:
  schedule:
    - cron: '0 8,12,16,20 * * *'
  workflow_dispatch:

jobs:
  update-epg:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Obtener EPG de movistarplus.es
        run: |
          python3 << 'PYEOF'
          import json, re, sys
          from datetime import datetime, timedelta
          import urllib.request, urllib.error

          CANALES = {
              'mplus':   'Movistar Plus+',
              'vamosd':  'M+ Vamos',
              'mliga':   'M+ LaLiga',
              'daznli':  'DAZN LaLiga',
              'chapio':  'Champions League',
              'cpdep':   'M+ Deportes',
              'arthur':  'M+ Deportes 2',
              'esp':     'Eurosport 1',
              'esp2':    'Eurosport 2',
              'm1sd':    'DAZN 1',
              'm2sd':    'DAZN 2',
              'tdep':    'Teledeporte',
              'tve':     'La 1',
              'la2':     'La 2',
              'a3':      'Antena 3',
              't5':      'Telecinco',
          }

          TODAY = datetime.now().strftime('%Y-%m-%d')
          BASE  = 'https://www.movistarplus.es'
          UA    = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/122 Safari/537.36'

          def get(url):
              req = urllib.request.Request(url, headers={
                  'User-Agent': UA,
                  'Accept': 'text/html,application/json,*/*',
                  'Accept-Language': 'es-ES,es;q=0.9',
              })
              with urllib.request.urlopen(req, timeout=15) as r:
                  return r.read().decode('utf-8', errors='replace')

          # ── Paso 1: obtener buildId de Next.js ───────────────────────────────
          print('Obteniendo buildId...')
          build_id = None
          try:
              html = get(BASE + '/programacion-tv')
              m = re.search(r'"buildId"\s*:\s*"([^"]+)"', html)
              if m:
                  build_id = m.group(1)
                  print(f'  buildId: {build_id}')
              else:
                  print('  buildId no encontrado en HTML')
          except Exception as e:
              print(f'  Error obteniendo página principal: {e}')

          def parse_programas(data):
              """Extrae lista de programas de la respuesta JSON de Next.js."""
              progs = []
              def buscar(obj, depth=0):
                  if depth > 12: return
                  if isinstance(obj, list):
                      # Lista de programas: items con hora y título
                      for item in obj:
                          if not isinstance(item, dict): continue
                          hora = (item.get('horaInicio') or item.get('startTime') or
                                  item.get('hora') or item.get('start') or
                                  item.get('time') or '')
                          titulo = (item.get('titulo') or item.get('title') or
                                    item.get('nombre') or item.get('name') or '')
                          hora_fin = (item.get('horaFin') or item.get('endTime') or
                                      item.get('fin') or item.get('end') or '')
                          if hora and titulo and len(str(titulo)) > 1:
                              hm = re.search(r'\d{1,2}:\d{2}', str(hora))
                              fm = re.search(r'\d{1,2}:\d{2}', str(hora_fin))
                              progs.append({
                                  'inicio': hm.group() if hm else str(hora)[:5],
                                  'fin':    fm.group() if fm else None,
                                  'titulo': str(titulo).strip(),
                                  'desc':   str(item.get('descripcion') or item.get('description') or '')[:120].strip(),
                              })
                      if progs: return
                      for item in obj:
                          buscar(item, depth+1)
                  elif isinstance(obj, dict):
                      for v in obj.values():
                          buscar(v, depth+1)
                          if progs: return
              buscar(data)
              return progs

          result = {}

          for slug, label in CANALES.items():
              progs = []

              # ── Método 1: /_next/data/{buildId}/programacion-tv/{slug}/{date}.json
              if build_id:
                  url = f'{BASE}/_next/data/{build_id}/programacion-tv/{slug}/{TODAY}.json'
                  try:
                      raw = get(url)
                      data = json.loads(raw)
                      progs = parse_programas(data)
                      if progs:
                          print(f'  [next/data] {label}: {len(progs)} programas')
                  except Exception as e:
                      print(f'  [next/data] {label}: {e}')

              # ── Método 2: HTML directo + __NEXT_DATA__ embebido
              if not progs:
                  url2 = f'{BASE}/programacion-tv/{slug}/{TODAY}'
                  try:
                      html2 = get(url2)
                      m2 = re.search(r'<script id="__NEXT_DATA__"[^>]*>(.*?)</script>', html2, re.DOTALL)
                      if m2:
                          data2 = json.loads(m2.group(1))
                          progs = parse_programas(data2)
                          if progs:
                              print(f'  [__NEXT_DATA__] {label}: {len(progs)} programas')
                          else:
                              # Guardar para debug
                              with open(f'/tmp/debug_{slug}.json', 'w') as f:
                                  json.dump(data2, f, indent=2)
                              print(f'  [__NEXT_DATA__] {label}: JSON encontrado pero sin programas — guardado en /tmp/debug_{slug}.json')
                      else:
                          print(f'  [HTML] {label}: sin __NEXT_DATA__ en HTML')
                  except Exception as e:
                      print(f'  [HTML] {label}: {e}')

              progs.sort(key=lambda x: x.get('inicio',''))
              result[label] = progs

          # ── Resumen ──────────────────────────────────────────────────────────
          print('\n── Resultado ───────────────────────────────────────────────')
          ok = 0
          for label, progs in result.items():
              if progs:
                  print(f'  OK  {label}: {len(progs)} prog — {progs[0]["inicio"]} {progs[0]["titulo"]}')
                  ok += 1
              else:
                  print(f'  --- {label}: VACIO')

          total = sum(len(v) for v in result.values())
          print(f'\nTotal: {total} programas en {ok}/{len(CANALES)} canales')

          if total == 0:
              print('ATENCION: 0 programas — manteniendo epg.json anterior')
              sys.exit(0)

          with open('epg.json', 'w', encoding='utf-8') as f:
              json.dump({
                  'actualizado': datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'),
                  'fuente': 'movistarplus.es',
                  'canales': result,
              }, f, ensure_ascii=False, indent=2)

          print('epg.json guardado OK')
          PYEOF

      - name: Commit y push
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add epg.json
          git diff --staged --quiet || git commit -m "EPG $(date -u '+%Y-%m-%d %H:%M UTC')"
          git pull --rebase origin main
          git push
